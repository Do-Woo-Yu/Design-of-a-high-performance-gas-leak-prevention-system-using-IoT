//*******************************************************************
// Project: 	4.3" (480x272 LCM) Testing software
// MPU:         STM32F429ZI(144Pin, 2MByte)
// Control IC:  RA8875
// Interface :  8080 Type Parallel 16bits
// Writen by:   Professor Oh Yang
// Date:        2022-05-26
// ver:  		01 (NEW)
// Tab size: 	4
//*******************************************************************
/* USER CODE BEGIN Includes */
#include "main.h"
#include "extern.h"
#include "user_define.h"

/* USER CODE END Includes */
//	RS 	WR# Access Cycle
//	0 	0 	Data Write
//	0 	1 	Data Read
//	1 	0 	CMD Write
//	1 	1 	Status Read



void write_cmd_b(byte cmd_b)
{	
	LCD_CMD_B = cmd_b;
/*
	LCD_CS = 0;
	LCD_RS = 1;
	LCD_RD = 1;
	LCD_BUS = cmd;
	LCD_WR = 0;
	LCD_WR = 1;
	LCD_CS = 1;
*/
}

void write_data_b(byte data_b)
{
	LCD_DATA_B = data_b;	
/*	LCD_CS = 0;
	LCD_RS = 0;
	LCD_RD = 1;
	LCD_BUS = Data;
	LCD_WR = 0;
	LCD_WR = 1;
	LCD_CS = 1;
*/
}

void write_cmd_data_b(byte cmd_b, byte data_b)
{
	//write_cmd(cmd);
	//write_data(Data);
	LCD_CMD_B = cmd_b;
	LCD_DATA_B = data_b;
}

void write_cmd_data_w(word cmd_w, word data_w)
{
	LCD_CMD_W = cmd_w;
	LCD_DATA_W = data_w;
}

byte Status_data;
byte read_status(void) 
{
	Status_data = LCD_CMD_B;	//*(byte *)0x60010000	//A16:1(RS:1 ---> Command Selection)
	return(Status_data);
/*	
	uchar cmd;
	LCD_BUS = 0xff;
	
	LCD_CS = 0;
	LCD_RS = 1;
	LCD_WR = 1;
	LCD_RD = 0;
	cmd = LCD_BUS;	
	LCD_RD = 1;
	LCD_CS = 1;
	return cmd;
*/
}

void Chk_Busy(void)
{
	byte temp; 	
	do
	{
		temp = read_status();
	}
	while((temp & 0x80)==0x80);	//0x80:Busy
}

byte Test_LCD_data1=0, Test_LCD_data2=0;
void RA8875_PLL_ini(void)
{  
	write_cmd_data_b(0x88, 0x0a);	//REG[88h] PLL Control Register 1 (PLLC1)===> (0x0a); PLLDIVN[4:0]===> 10
		//LCD_bCMD = 0x88; 	//write_cmd(0x88) : REG[88h] PLL Control Register 1 (PLLC1)
		//LCD_bDATA = 0x0a; 	//write_data(0x0a); PLLDIVN[4:0]===> 10
	Test_LCD_data1 = LCD_DATA_B;	
	HAL_Delay(10);		//10msec Delay, delay_ms(5);
	
	write_cmd_data_b(0x89, 0x02);	//REG[89h] PLL Control Register 2 (PLLC2)===> (0x02); PLLDIVK[2:0]===> 2
		//LCD_bCMD = 0x89; 	//write_cmd(0x89) : REG[89h] PLL Control Register 2 (PLLC2)
		//LCD_bDATA = 0x02; 	//write_data(0x02); PLLDIVK[2:0]===> 2
	Test_LCD_data2 = LCD_DATA_B;
	HAL_Delay(10);		//10msec Delay
}	

//*******************************************************************
//
//*******************************************************************

void LCD_Init(void)
{ 	
	RA8875_PLL_ini();
	write_cmd_data_b(0x10, 0x0F);	//REG[10h] System Configuration Register (SYSR)===> 16bpp(65K color), 16bit Bus I/F
		//LCD_CMD = 0x10;		//write_cmd(0x10);  //SYSR   bit[4:3]=00 256 color  bit[2:1]=  00 8bit MPU interface
		//write_data(0x0c);   // if 8bit MCU interface   and 65k color display  						    
		//write_data(0x0F); // if 16bit MCU interface   and 65k color display  
	
	//==============	Display Window	320x240 ==================	
	write_cmd_data_b(0x04, 0x82);	//REG[04h] Pixel Clock Setting Register (PCSR)===> 16bpp(65K color), 16bit Bus I/F
		//write_cmd(0x04);     //set PCLK invers
		//write_data(0x82); 	//PDAT is fetched at PCLK falling edge. 10b: PCLK period = 4 times of System Clock period.
		//delay_ms(1);
	
	//Horizontal set
	write_cmd_b(0x14); //HDWR//Horizontal Display Width Setting Bit[6:0] 
		write_data_b(0x3B);//Horizontal display width(pixels) = (HDWR + 1)*8   
	write_cmd_b(0x15); //Horizontal Non-Display Period Fine Tuning Option Register (HNDFTR)
		write_data_b(0x00);//Horizontal Non-Display Period Fine Tuning(HNDFT) [3:0]  
	write_cmd_b(0x16); //HNDR//Horizontal Non-Display Period Bit[4:0] 
		write_data_b(0x01);//Horizontal Non-Display Period (pixels) = (HNDR + 1)*8  
	write_cmd_b(0x17); //HSTR//HSYNC Start Position[4:0] 
		write_data_b(0x00);//HSYNC Start Position(PCLK) = (HSTR + 1)*8 
	write_cmd_b(0x18); //HPWR//HSYNC Polarity ,The period width of HSYNC. 
		write_data_b(0x05);//HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8 
	
	//Vertical set 
	write_cmd_b(0x19); //VDHR0 //Vertical Display Height Bit [7:0] 
		write_data_b(0x0f);//Vertical pixels = VDHR + 1
	write_cmd_b(0x1A); //VDHR1 //Vertical Display Height Bit [8] 
		write_data_b(0x01);//Vertical pixels = VDHR + 1 
	write_cmd_b(0x1B); //VNDR0 //Vertical Non-Display Period Bit [7:0]
		write_data_b(0x02);//Vertical Non-Display area = (VNDR + 1) 
	write_cmd_b(0x1C); //VNDR1 //Vertical Non-Display Period Bit [8] 
		write_data_b(0x00);//Vertical Non-Display area = (VNDR + 1)   
	write_cmd_b(0x1D); //VSTR0 //VSYNC Start Position[7:0]
		write_data_b(0x07);//VSYNC Start Position(PCLK) = (VSTR + 1) 
	write_cmd_b(0x1E); //VSTR1 //VSYNC Start Position[8] 
		write_data_b(0x00);//VSYNC Start Position(PCLK) = (VSTR + 1) 
	write_cmd_b(0x1F); //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
		write_data_b(0x09);//VSYNC Pulse Width(PCLK) = (VPWR + 1) 
	
	Active_Window(0,479,0,271);
	
	write_cmd_data_b(0x8A, 0xC8);	//REG[8Ah] PWM1 Control Register (P1CR)===> 0xC8:PWM1 Clock(SYS_CLK/256)
		//write_cmd(0x8a);	//1
		//write_data(0xc8);
	
	write_cmd_data_b(0x8B, 0xFF);	//REG[8Bh] PWM1 Duty Cycle Register (P1DCR)===> 0xFF:256/256 Duty with PWM1 clock source.
		//write_cmd(0x8b);	
		//write_data(0xff);
	
	write_cmd_data_b(0x01, 0x80);	//REG[01h] Power and Display Control Register (PWRR)===> 0x80:Display ON
		//write_cmd(0x01);	
		//write_data(0x80);
}

//*******************************************************************
//
//*******************************************************************

void clear_all(word b_color)
{ 
	Background_Color(b_color);
	write_cmd_b(0x8e);
	write_data_b(0x80);
	Chk_Busy();
	write_cmd_b(0x8e);
	write_data_b(0x00);
	write_cmd_data_b(0x40, 0x00);
}

//*******************************************************************
//display Russia block            
//*******************************************************************

void dis_block(void)
{
	byte x1, y1, x2, y2, dat;
	
	dat=0;
	
	write_cmd_data_b(0x10, 0x0F);	//65K Color, 16bit MCU I/F
		//write_bcmd(0x10); 		//SYSR   bit[4:3]=00 256 color  bit[2:1]=  00 8bit MPU interface
		//write_bdata(0x00);		// if 8bit MCU interface   and 65k color display 
	XY_Coordinate(0, 0);
	for(y1=17;y1>0;y1--)
	{
		for(y2=16;y2>0;y2--)
		for(x1=30;x1>0;x1--)
		{
			for(x2=16;x2>0;x2--)
			{
				write_data_b(dat);
			}
			dat=~dat;
		}
		dat=~dat;
	}
	HAL_Delay(1000);	//delay_ms(1000);
	write_cmd_data_b(0x10, 0x0F);	//65K Color, 16bit MCU I/F
		//write_bcmd(0x10);  	//SYSR   bit[4:3]=00 256 color  bit[2:1]=  00 8bit MPU interface
		//write_bdata(0x0c);	// if 8bit MCU interface   and 65k color display 
}

void dis_kong(word x, word y, word color)
{
	byte i, j;

	for(i=0;i<32;i++)
	{
		XY_Coordinate(x, y+i);
		for(j=0;j<32;j++)
		{
			//write_data_b(color);
			write_data_b(color>>8);
			write_data_b(color);
		}
	}	
}

//*******************************************************************
//display field
//*******************************************************************
void dis_field(void)
{
	Draw_Line(0,0,479,0,white);
	Draw_Line(479,0,479,271,white);
	Draw_Line(0,0,0,271,white);
	Draw_Line(0,271,479,271,white);
	HAL_Delay(1000);	//delay_ms(1000);
}

//*******************************************************************
//display seven color
//*******************************************************************

byte Color_matrix[]={0xe0,0x1c,0x03,0xfc,0xe3,0x1f,0x00,0xff};
void dis_seven_color(void)
{
	word x,y,high;
	byte color=0;
	byte pic1;
	
	write_cmd_data_b(0x10, 0x0F);	//65K Color, 16bit MCU I/F
		//write_bcmd(0x10);  	//SYSR   bit[4:3]=00 256 color  bit[2:1]=  00 8bit MPU interface
		//write_bdata(0x00);	// if 8bit MCU interface   and 65k color display
	XY_Coordinate(0,0);
	for(y=0;y<8;y++)	//Display 7 colour
	{
		pic1 = Color_matrix[color++];
		for(high=34;high>0;high--)
			for(x=480;x>0;x--)
			{
				write_data_b(pic1);
			}
	}
	HAL_Delay(1000);	//delay_ms(1000);
	write_cmd_data_b(0x10, 0x0F);	//65K Color, 16bit MCU I/F
		//write_bcmd(0x10);  	//SYSR   bit[4:3]=00 256 color  bit[2:1]=  00 8bit MPU interface
		//write_bdata(0x0F);	//if 16bit MCU interface   and 65k color display
		//write_bdata(0x0c);	// if 8bit MCU interface   and 65k color display
}


    
//*******************************************************************
// 定义ASCII字库32列*32行，字体arial宽48高32锁定
//取模 阴码顺序逐行式	
//*******************************************************************

byte zheng[]=
{
    0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x7F,0xFF,0xFF,0xFE,
    0x7F,0xFF,0xFF,0xFE,0x7F,0xFF,0xFF,0xFE,
    0x7F,0xFF,0xFF,0xFE,0x7F,0xFF,0xFF,0xFE,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x07,0xE0,0x00,0x00,0x07,0xE0,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"+",0*/
};

void dis_zheng(word x, word y, word back_color, word txt_color, byte *Lib)
{
	byte i,j,k;
	
	for(i=0;i<32;i++)				    
	{
		for(j=0;j<4;j++)			   
		{
			XY_Coordinate(x+8*j, y+i);
			for(k=0;k<8;k++)
			{
				if(Lib[4*i+j]<<k&0x80)				
				{
					write_data_b(txt_color>>8);
					write_data_b(txt_color);
					//write_data(txt_color>>8);
					//write_data(txt_color);
				}
				else
				{
					write_data_b(back_color>>8);
					write_data_b(back_color);
				}
			}   
		}
	}									
}

//*******************************************************************
//
//*******************************************************************
//REG[30h]~REG[37h]
//					(0, 479, 0, 271)
void Active_Window(word XL, word XR, word YT, word YB)
{
	//setting active window X
	//write_cmd_data_w(0x30, XL);		//REG[30h] Horizontal Start Point 0 of Active Window (HSAW0)===> X:0~479(Low byte)	
		write_cmd_b(0x30);//HSAW0
		write_data_b(XL); 
	//write_cmd_data_b(0x31, XL>>8);	//REG[31h] Horizontal Start Point 1 of Active Window (HSAW1)===> X:0~479(High byte)
		write_cmd_b(0x31);//HSAW1	   
		write_data_b(XL>>8);
	
//	write_cmd_data_w(0x34, XR);		//REG[34h] Horizontal End Point 0 of Active Window (HEAW0)===> X:0~479(Low byte)
		write_cmd_b(0x34);//HEAW0
		write_data_b(XR);
	//write_cmd_data_b(0x35, XR>>8);	//REG[35h] Horizontal End Point 1 of Active Window (HEAW1)===> X:0~479(High byte)
		write_cmd_b(0x35);//HEAW1	   
		write_data_b(XR>>8);
	
	//setting active window Y
//	write_cmd_data_w(0x32, YT);		//REG[32h] Vertical Start Point 0 of Active Window (VSAW0)===> Y:0~271(Low byte)	
		write_cmd_b(0x32);//VSAW0
		write_data_b(YT);  
	//write_cmd_data(0x33, YT>>8);	//REG[33h] Vertical Start Point 1 of Active Window (VSAW1)===> Y:0~271(High byte)	
		write_cmd_b(0x33);//VSAW1	   
		write_data_b(YT>>8);
	
//	write_cmd_data_w(0x36, YB);		//REG[36h] Vertical End Point of Active Window 0 (VEAW0)===> Y:0~271(Low byte)	
		write_cmd_b(0x36);//VEAW0
		write_data_b(YB); 
	
	//write_cmd_data(0x37, YB>>8);	//REG[37h] Vertical End Point of Active Window 1 (VEAW1)===> Y:0~271(High byte)	
		write_cmd_b(0x37);//VEAW1	   
		write_data_b(YB>>8);
}
    
//*******************************************************************
//
//*******************************************************************
//REG[46h]~REG[49h]
void XY_Coordinate(word X, word Y)
{
	write_cmd_data_b(0x40, 0x00);	//REG[40h] Memory Write Control Register 0 (MWCR0) ===> Graphic mode, Normal display, Left-> Right, Top->Down
	
//	write_cmd_data_w(0x46, X);	//REG[46h] Memory Write Cursor Horizontal Position Register 0 (CURH0)
		write_cmd_b(0x46);
		write_data_b(X);  
	
	//write_cmd_data_b(0x47, X>>8);	//REG[47h] Memory Write Cursor Horizontal Position Register 1 (CURH1)
		write_cmd_b(0x47);	   
		write_data_b(X>>8);
	
//	write_cmd_data_w(0x48, Y);	//REG[48h] Memory Write Cursor Vertical Position Register 0 (CURV0)
		write_cmd_b(0x48);
		write_data_b(Y);  
	//write_cmd_data(0x48, Y>>8);	//REG[49h] Memory Write Cursor Vertical Position Register 1 (CURV1)
		write_cmd_b(0x49);	   
		write_data_b(Y>>8);
	
	LCD_CMD_B = 0x02;	//捞饶俊 单捞磐甫 佬绊/静扁 困秦 霖厚窃, write_cmd(0x02);//set CMD02 to  prepare data write
}
    
//*******************************************************************
//
//*******************************************************************

void Background_Color(word color)
{
	write_cmd_b(0x60);
	write_data_b((color&0xf800)>>11);
	
	write_cmd_b(0x61);
	write_data_b((color&0x07e0)>>5);
	
	write_cmd_b(0x62);
	write_data_b((color&0x001f));
} 


void Foreground_Color(word color)
{	    
	write_cmd_b(0x63);
	write_data_b((color&0xf800)>>11);
	
	write_cmd_b(0x64);
	write_data_b((color&0x07e0)>>5);
	
	write_cmd_b(0x65);
	write_data_b((color&0x001f));
} 


//REG[2Ah]REG[2Bh]REG[2Ch]REG[2Dh]
void Font_Coordinate(word X, word Y)
{
	write_cmd_b(0x2A);//HOFS0
	write_data_b(X);
	
	write_cmd_b(0x2B);//HOFS1	   
	write_data_b(X>>8);
	
	write_cmd_b(0x2C);//VOFS0
	write_data_b(Y);
	
	write_cmd_b(0x2D);//VOFS1	   
	write_data_b(Y>>8); 
}
    
void String(word X, word Y, word b_color, word t_color, byte *str)
{   
	write_cmd_data_b(0x40,0x80);
	write_cmd_data_b(0x21,0x00);
	write_cmd_data_b(0x22,0x05);
	write_cmd_data_b(0x2e,0x80);	
	write_cmd_data_b(0x2f,0x00);   
	Background_Color(b_color);
	Foreground_Color(t_color);
	Font_Coordinate(X,Y);
	write_cmd_b(0x02);
	while(*str != '\0')
	{
		write_data_b(*str);
		++str;	 	
		Chk_Busy();		
	} 
}

void String_external(word X, word Y, word b_color, word t_color, byte *str)
{   
	write_cmd_data_b(0x40,0x80);
	write_cmd_data_b(0x21,0x20);
	write_cmd_data_b(0x22,0x00);
	write_cmd_data_b(0x05,0x28);
	write_cmd_data_b(0x06,0x03);
	write_cmd_data_b(0x2e,0x40);	
	write_cmd_data_b(0x2f,0x41);  
	Background_Color(b_color);
	Foreground_Color(t_color);
	Font_Coordinate(X,Y);
	write_cmd_b(0x02);
	while(*str != '\0')
	{
		write_data_b(*str);
		++str;	 	
		Chk_Busy();		
	}
}
    
byte STR1[]={0xff,0xfe,0xfd,0x00};                                                              
void dis_text(word b_color)
{
	clear_all(b_color);
	String(136,36,blue,violet,"4.3 Inch TFT LCD");
	String(144,78,blue,green,"480*272 DOTS");
	String_external(140,124,blue,red,"没林措");
	String_external(212,120,blue,red,": RA8875");
	String_external(144,166,blue,yellow,"图形液晶显示模块");
	String(128,204,blue,cyan,"GRAPHIC MODULE");
	HAL_Delay(1000);	//delay_ms(1000);
}

void Draw_Circle(word X, word Y, word R, word color, byte fill)
{
	write_cmd_b(0x99);
	write_data_b(X);
	write_cmd_b(0x9a);	   
	write_data_b(X>>8);  
	  
	write_cmd_b(0x9b);
	write_data_b(Y);
	write_cmd_b(0x9c);	   
	write_data_b(Y>>8);
	
	write_cmd_b(0x9d);
	write_data_b(R);
	
	Foreground_Color(color);
	if(fill==1) 
		write_cmd_data_b(0x90,0x60);
	else    
		write_cmd_data_b(0x90,0x40);
	HAL_Delay(10);	//delay_ms(5);
} 


void Draw_Ellipse_cursor(word X,word Y, word R1, word R2)
{
	write_cmd_b(0xA5);
	write_data_b(X);
	write_cmd_b(0xA6);	   
	write_data_b(X>>8);  
	  
	write_cmd_b(0xA7);
	write_data_b(Y);
	write_cmd_b(0xA8);	   
	write_data_b(Y>>8);
	
	write_cmd_b(0xA1);
	write_data_b(R1);
	write_cmd_b(0xA2);	   
	write_data_b(R1>>8);  
	  
	write_cmd_b(0xA3);
	write_data_b(R2);
	write_cmd_b(0xA4);	   
	write_data_b(R2>>8);
}

void Draw_Ellipse_Line(word X, word Y, word R1, word R2, word color)
{
	Draw_Ellipse_cursor(X,Y,R1,R2);
	Foreground_Color(color);
	write_cmd_data_b(0xA0,0x90); 
	HAL_Delay(10);	//delay_ms(5);
	write_cmd_data_b(0xA0,0x91);
	HAL_Delay(10);	//delay_ms(5);
	write_cmd_data_b(0xA0,0x92); 
	HAL_Delay(10);	//delay_ms(5);
	write_cmd_data_b(0xA0,0x93);
	HAL_Delay(10);	//delay_ms(5);
} 

void Draw_Ellipse_Wave(word X, word Y, word R1, word R2, word color, byte wave)
{
	Draw_Ellipse_cursor(X,Y,R1,R2);
	Foreground_Color(color);
	if(wave==1) 
	{
		write_cmd_data_b(0xA0,0x91); 
		HAL_Delay(10);	//delay_ms(5);
		write_cmd_data_b(0xA0,0x92);     
		HAL_Delay(10);	//delay_ms(5);
	}
	else
	{        
		write_cmd_data_b(0xA0,0x90); 
		HAL_Delay(10);	//delay_ms(5);
		write_cmd_data_b(0xA0,0x93);
		HAL_Delay(10);	//delay_ms(5);
	}
}
     
void  Draw_Ellipse(word X, word Y, word R1, word R2, word color, byte fill)
{
	Draw_Ellipse_cursor(X,Y,R1,R2);
	Foreground_Color(color);
	if(fill==1) 
		write_cmd_data_b(0xA0,0xC0); 
	else    
		write_cmd_data_b(0xA0,0x80);
	HAL_Delay(10);	//delay_ms(5);
} 


void Draw_Line_cursor(word XS, word YS, word XE, word YE)
{	
	write_cmd_data_b(0x91, XS);		//REG[91h] Draw Line/Square Horizontal Start Address Register0 (DLHSR0): Low byte
		//write_cmd(0x91);
		//write_data(XS);
	
	write_cmd_data_b(0x92, XS>>8);	//REG[91h] Draw Line/Square Horizontal Start Address Register0 (DLHSR0): Low byte
		//write_cmd(0x92);	   
		//write_data(XS>>8);
	
	write_cmd_b(0x93);
	write_data_b(YS);
	write_cmd_b(0x94);	   
	write_data_b(YS>>8);
	
	write_cmd_b(0x95);
	write_data_b(XE);
	write_cmd_b(0x96);	   
	write_data_b(XE>>8);
	
	write_cmd_b(0x97);
	write_data_b(YE);
	write_cmd_b(0x98);	   
	write_data_b(YE>>8);
}

void Draw_Triangle_cursor(word X3, word Y3)
{
	write_cmd_data_b(0xA9, X3);		//REG[A9h] Draw Triangle Point 2 Horizontal Address Register0 (DTPH0) : Low byte
		//write_cmd(0xA9);
		//write_data(X3);
	write_cmd_data_b(0xAA, X3>>8);	//REG[AAh] Draw Triangle Point 2 Horizontal Address Register1 (DTPH1) : High byte
		//write_cmd(0xAA);	   
		//write_data(X3>>8);
	
	write_cmd_data_b(0xAB, Y3);		//REG[ABh] Draw Triangle Point 2 Vertical Address Register0 (DTPV0) : Low byte
		//write_cmd(0xAB);
		//write_data(Y3);
	write_cmd_data_b(0xAC, Y3>>8);	//REG[ACh] Draw Triangle Point 2 Vertical Address Register1 (DTPV1) : High byte
		//write_cmd(0xAC);	   
		//write_data(Y3>>8);
}
    
void Draw_Line(word XS, word YS, word XE, word YE, word color)
{	
	Draw_Line_cursor(XS, YS, XE, YE);
	Foreground_Color(color);
	write_cmd_data_b(0x90, 0x80);	//REG[90h] Draw Line/Circle/Square Control Register (DCR), 0x80(Start the drawing function)
	HAL_Delay(10);	//delay_ms(5);
}

void Draw_Square(word XS, word YS, word XE, word YE, word color, byte fill)
{	
	Draw_Line_cursor(XS, YS, XE, YE);
	Foreground_Color(color);
	if(fill==1) 
		write_cmd_data_b(0x90, 0xB0);	//REG[90h] Draw Line/Circle/Square Control Register(DCR), 0xB0(Start the drawing function, Stop Circle, Fill, Square)
	else    
		write_cmd_data_b(0x90, 0x90);	//REG[90h] Draw Line/Circle/Square Control Register(DCR), 0xB0(Start the drawing function, Stop Circle, Non Fill, Square)
	HAL_Delay(10);	//delay_ms(5);
}

void Draw_Circle_Square(word XS, word YS, word XE, word YE, word X, word Y, word R1, word R2, word color, byte fill)
{	
	Draw_Line_cursor(XS,YS,XE,YE);
	Draw_Ellipse_cursor(X,Y,R1,R2);
	Foreground_Color(color);
	if(fill==1) 
		write_cmd_data_b(0xA0,0xE0); 
	else    
		write_cmd_data_b(0xA0,0xA0);
	HAL_Delay(10);	//delay_ms(5);
}

void Draw_Triangle(word XS, word YS, word XE, word YE, word X3, word Y3, word color, byte fill)
{	
	Draw_Line_cursor(XS,YS,XE,YE);
	Draw_Triangle_cursor(X3,Y3);
	Foreground_Color(color);
	if(fill==1) 
		write_cmd_data_b(0x90,0xA1); 
	else    
		write_cmd_data_b(0x90,0x81);
	HAL_Delay(10);	//delay_ms(5);
}

//*******************************************************************
//
//*******************************************************************

void draw_graphic(word b_color, word color, byte fill)
{
	clear_all(b_color);
	Draw_Line(0,0,479,0,color);
	Draw_Line(479,0,479,271,color);
	Draw_Line(0,0,0,271,color);
	Draw_Line(0,271,479,271,color);
	Draw_Circle(160,50,30,color,0);
	Draw_Ellipse(148,40,8,4,color,fill);
	Draw_Ellipse(172,40,8,4,color,fill);
	Draw_Triangle(160,50,165,60,155,60,color,fill);
	Draw_Ellipse(160,70,10,4,color,fill);
	Draw_Ellipse_Line(194,50,4,8,color);
	Draw_Ellipse_Line(126,50,4,8,color);
	Draw_Square(155,80,165,90,color,fill);
	Draw_Circle_Square(130,90,190,150,0,0,10,10,color,fill);
	Draw_Square(140,150,155,200,color,fill);
	Draw_Square(165,150,180,200,color,fill);
	Draw_Triangle(140,200,130,220,155,200,color,fill);
	Draw_Triangle(180,200,190,220,165,200,color,fill);
	Draw_Triangle(190,95,220,150,190,115,color,fill);
	Draw_Circle(220,150,5,color,fill);
	Draw_Triangle(130,95,100,150,130,115,color,fill);
	Draw_Circle(100,150,5,color,fill);
	HAL_Delay(1000);	//delay_ms(1000);
}

void dis_graphic(word b_color, word color)
{
	clear_all(b_color);
	Draw_Line(0,0,479,0,color);
	Draw_Line(479,0,479,271,color);
	Draw_Line(0,0,0,271,color);
	Draw_Line(0,271,479,271,color);
	Draw_Line(0,79,479,79,color);
	Draw_Line(0,159,479,159,color);
	Draw_Triangle(10,70,40,10,70,70,color,0);
	Draw_Triangle(90,10,120,70,150,10,color,0);
	Draw_Triangle(170,10,170,70,230,40,color,0);
	Draw_Triangle(250,40,310,10,310,70,color,0);
	Draw_Ellipse(60,120,50,30,color,0);
	Draw_Ellipse(150,120,20,30,color,0);      
	Draw_Ellipse_Wave(200,120,15,30,color,1);
	Draw_Ellipse_Wave(230,120,15,30,color,0);
	Draw_Ellipse_Wave(260,120,15,30,color,1);
	Draw_Ellipse_Wave(290,120,15,30,color,0);
	Draw_Square(10,170,90,230,color,0);
	Draw_Circle_Square(100,170,170,230,0,0,10,10,color,0);
	Draw_Circle(210,200,30,color,0);
	Draw_Square(250,170,310,230,color,0);
	HAL_Delay(1000);	//delay_ms(1000);
}

/*
void main_ref(void)
{   
	LCD_Reset();
	LCD_Initial();	
	
	while(1)
	{
		clear_all(black);//清除显示内容保留底色
		dis_field();
		dis_picture(0,0,0,0x0000);
		dis_seven_color();
		dis_block();
		clear_all(white);
		delay_ms(1000);
		clear_all(red);
		delay_ms(1000);
		clear_all(blue);
		delay_ms(1000);
		clear_all(green);
		delay_ms(1000);
		dis_text(blue);
		draw_graphic(blue,white,0);
		dis_graphic(red, white);
		clear_all(blue);
		dis_zheng(0,0,blue,white,zheng);
		dis_zheng(448,0,blue,white,zheng);
		dis_zheng(0,240,blue,white,zheng);
		dis_zheng(448,240,blue,white,zheng);
		dis_zheng(224,120,blue,white,zheng);
	}   
}
*/
///////////////////// End of LT043C_16Bit.c /////////////////////
